<?xml version="1.0" encoding="UTF-8"?>
<!--
Copyright 2013 European Molecular Biology Laboratory, Heidelberg,
Germany and Novo Nordisk A/S, Bagsvaerd, Denmark.

Licensed under the Apache License, Version 2.0 (the "License"); you
may not use this file except in compliance with the License.  You may
obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0
     
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
implied. See the License for the specific language governing
permissions and limitations under the License.
-->    
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
    targetNamespace="http://www.pharmml.org/2013/03/Maths"
    xmlns:math="http://www.pharmml.org/2013/03/Maths" elementFormDefault="qualified"
    attributeFormDefault="unqualified" version="0.4.1"
    xmlns:ct="http://www.pharmml.org/2013/03/CommonTypes"
    xmlns:ds="http://www.pharmml.org/2013/08/Dataset"
    xmlns:mdef="http://www.pharmml.org/2013/03/ModelDefinition">
    
    <xs:import namespace="http://www.pharmml.org/2013/03/ModelDefinition" 
        schemaLocation="http://www.pharmml.org/2013/03/ModelDefinition"/>

    <xs:import namespace="http://www.pharmml.org/2013/03/CommonTypes"
        schemaLocation="http://www.pharmml.org/2013/03/CommonTypes"/>
    
    <xs:import namespace="http://www.pharmml.org/2013/08/Dataset"
        schemaLocation="http://www.pharmml.org/2013/08/Dataset"/>
    
    <xs:complexType name="BinopType">
        <xs:annotation>
            <xs:documentation>
                A binary operator describing a numerical operation. Takes two operands (as you would expect).
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ct:PharmMLRootType">
                <xs:sequence>
                    <xs:choice>
                        <xs:annotation>
                            <xs:documentation>Operand 1</xs:documentation>
                        </xs:annotation> 
                        <xs:element ref="ct:Scalar"/>
                        <xs:element ref="ct:SymbRef"/>
                        <xs:element ref="math:Constant"/>
                        <xs:element ref="math:Binop"/>
                        <xs:element ref="math:Uniop"/>
                        <xs:element ref="math:FunctionCall"/>
                        <xs:element ref="math:Sum"/>
                        <xs:element ref="math:Product"/>
                        <xs:element ref="ct:Delay"/>
                        <xs:element ref="math:VectorSelector"/>
                        <xs:element ref="math:MatrixSelector"/>
                        <xs:element ref="mdef:Probability"/>
                    </xs:choice>
                    <xs:choice>
                        <xs:annotation>
                            <xs:documentation>Operand 2</xs:documentation>
                        </xs:annotation>
                        <xs:element ref="ct:Scalar"/>
                        <xs:element ref="ct:SymbRef"/>
                        <xs:element ref="math:Constant"/>
                        <xs:element ref="math:Binop"/>
                        <xs:element ref="math:Uniop"/>
                        <xs:element ref="math:FunctionCall"/>
                        <xs:element ref="math:Sum"/>
                        <xs:element ref="math:Product"/>
                        <xs:element ref="ct:Delay"/>
                        <xs:element ref="math:VectorSelector"/>
                        <xs:element ref="math:MatrixSelector"/>
                        <xs:element ref="mdef:Probability"/>
                    </xs:choice>
                </xs:sequence>
                <xs:attribute name="op" use="required">
                    <xs:annotation>
                        <xs:documentation>The binary operator type. See the specification for a more detailed description.</xs:documentation>
                    </xs:annotation>
                    <xs:simpleType>
                        <xs:restriction base="xs:Name">
                            <xs:enumeration value="plus"/>
                            <xs:enumeration value="minus"/>
                            <xs:enumeration value="times"/>
                            <xs:enumeration value="divide"/>
                            <xs:enumeration value="power"/>
                            <xs:enumeration value="logx"/>
                            <xs:enumeration value="root"/>
                            <xs:enumeration value="min"/>
                            <xs:enumeration value="max"/>
                            <xs:enumeration value="rem"/>
                        </xs:restriction>
                    </xs:simpleType>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="UniopType">
        <xs:annotation>
            <xs:documentation>
                The unary operator type. Takes one operator.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="math:ExprType">
                <xs:annotation>
                    <xs:documentation>
                        Extends the expression which is in effect the operand.
                    </xs:documentation>
                </xs:annotation>
                <xs:attribute name="op" use="required">
                    <xs:annotation>
                        <xs:documentation>The operator. More detail in the specification.</xs:documentation>
                    </xs:annotation>
                    <xs:simpleType>
                        <xs:restriction base="xs:Name">
                            <xs:enumeration value="abs"/>
                            <xs:enumeration value="exp"/>
                            <xs:enumeration value="factorial"/>
                            <xs:enumeration value="factln"/>
                            <xs:enumeration value="gammaln"/>
                            <xs:enumeration value="log"/>
                            <xs:enumeration value="log2"/>
                            <xs:enumeration value="log10"/>
                            <xs:enumeration value="logistic"/>
                            <xs:enumeration value="logit"/>
                            <xs:enumeration value="normcdf"/>
                            <xs:enumeration value="probit"/>
                            <xs:enumeration value="minus"/>
                            <xs:enumeration value="sqrt"/>
                            <xs:enumeration value="sin"/>
                            <xs:enumeration value="cos"/>
                            <xs:enumeration value="tan"/>
                            <xs:enumeration value="cot"/>
                            <xs:enumeration value="atan2"/>
                            <xs:enumeration value="sec"/>
                            <xs:enumeration value="csc"/>
                            <xs:enumeration value="sinh"/>
                            <xs:enumeration value="cosh"/>
                            <xs:enumeration value="tanh"/>
                            <xs:enumeration value="sech"/>
                            <xs:enumeration value="csch"/>
                            <xs:enumeration value="coth"/>
                            <xs:enumeration value="arcsin"/>
                            <xs:enumeration value="arccos"/>
                            <xs:enumeration value="arctan"/>
                            <xs:enumeration value="arcsec"/>
                            <xs:enumeration value="arccsc"/>
                            <xs:enumeration value="arccot"/>
                            <xs:enumeration value="arcsinh"/>
                            <xs:enumeration value="arccosh"/>
                            <xs:enumeration value="arctanh"/>
                            <xs:enumeration value="arcsech"/>
                            <xs:enumeration value="arccsch"/>
                            <xs:enumeration value="arccoth"/>
                            <xs:enumeration value="floor"/>
                            <xs:enumeration value="ceiling"/>
                        </xs:restriction>
                    </xs:simpleType>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="ConstantType">
        <xs:annotation>
            <xs:documentation>
                The schema type defining a mathematical constant.
            </xs:documentation>
        </xs:annotation>
        <xs:attribute name="op" use="required">
            <xs:annotation>
                <xs:documentation>The type of constant.</xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:Name">
                    <xs:enumeration value="notanumber"/>
                    <xs:enumeration value="pi"/>
                    <xs:enumeration value="exponentiale"/>
                    <xs:enumeration value="infinity"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="PiecewiseType">
        <xs:annotation>
            <xs:documentation>The schema type defining a piecewise function.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element maxOccurs="unbounded" name="Piece" type="math:PieceType">
                <xs:annotation>
                    <xs:documentation>Defines a piece in the piecewise function.</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="PieceType">
        <xs:annotation>
            <xs:documentation>The schema type defining a `piece' in a piecewise function.</xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="math:ExprType">
                <xs:sequence>
                    <xs:element ref="math:Condition"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="ExprType">
        <xs:annotation>
            <xs:documentation>The schema type defining a mathematical expression.</xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ct:PharmMLRootType">
                <xs:choice maxOccurs="1" minOccurs="1">
                    <xs:element ref="ct:Scalar"/>
                    <xs:element maxOccurs="1" minOccurs="1" ref="ct:SymbRef"/>
                    <xs:element ref="math:Constant"/>
                    <xs:element ref="math:Binop"/>
                    <xs:element ref="math:Uniop"/>
                    <xs:element ref="math:FunctionCall"/>
                    <xs:element ref="math:Sum"/>
                    <xs:element ref="math:Product"/>
                    <xs:element ref="math:VectorSelector"/>
                    <xs:element ref="math:MatrixSelector"/>
                    <xs:element ref="mdef:Probability"/>
                </xs:choice>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="LogicConditionType">
        <xs:annotation>
            <xs:documentation>The schema type defining logical condition.</xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ct:PharmMLRootType">
                <xs:choice maxOccurs="1">
                    <xs:element ref="math:LogicBinop"/>
                    <xs:element ref="math:LogicUniop"/>
                    <xs:element ref="ct:Boolean"/>
                    <xs:element ref="math:Otherwise"/>
                </xs:choice>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="LogicBinOpType">
        <xs:annotation>
            <xs:documentation>The schema type defining a binary logical operator.</xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ct:PharmMLRootType">
                <xs:sequence>
                    <xs:choice>
                        <xs:annotation>
                            <xs:documentation>Operand 1.</xs:documentation>
                        </xs:annotation>
                        <xs:element ref="math:LogicBinop"/>
                        <xs:element ref="math:LogicUniop"/>
                        <xs:element ref="ct:Scalar"/>
                        <xs:element ref="math:Constant"/>
                        <xs:element ref="ct:SymbRef"/>
                        <xs:element ref="ds:ColumnRef"/>
                        <xs:element ref="math:Binop"/>
                        <xs:element ref="math:Uniop"/>
                        <xs:element ref="math:FunctionCall"/>
                        <xs:element ref="math:Sum"/>
                        <xs:element ref="math:Product"/>
                        <xs:element ref="math:VectorSelector"/>
                        <xs:element ref="math:MatrixSelector"/>
                        <xs:element ref="mdef:Probability"/>
                    </xs:choice>
                    <xs:choice>
                        <xs:annotation>
                            <xs:documentation>Operand 2.</xs:documentation>
                        </xs:annotation>
                        <xs:element ref="math:LogicBinop"/>
                        <xs:element ref="math:LogicUniop"/>
                        <xs:element ref="ct:Scalar"/>
                        <xs:element ref="math:Constant"/>
                        <xs:element ref="ct:SymbRef"/>
                        <xs:element ref="math:Binop"/>
                        <xs:element ref="math:Uniop"/>
                        <xs:element ref="math:FunctionCall"/>
                        <xs:element ref="math:Sum"/>
                        <xs:element ref="math:Product"/>
                        <xs:element ref="math:VectorSelector"/>
                        <xs:element ref="math:MatrixSelector"/>
                        <xs:element ref="mdef:Probability"/>
                    </xs:choice>
                </xs:sequence>
                <xs:attribute name="op" use="required">
                    <xs:annotation>
                        <xs:documentation>The logical binary operator type.</xs:documentation>
                    </xs:annotation>
                    <xs:simpleType>
                        <xs:restriction base="xs:Name">
                            <xs:enumeration value="lt"/>
                            <xs:enumeration value="leq"/>
                            <xs:enumeration value="gt"/>
                            <xs:enumeration value="geq"/>
                            <xs:enumeration value="eq"/>
                            <xs:enumeration value="neq"/>
                            <xs:enumeration value="and"/>
                            <xs:enumeration value="or"/>
                            <xs:enumeration value="xor"/>
                        </xs:restriction>
                    </xs:simpleType>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="LogicExprType">
        <xs:annotation>
            <xs:documentation>A logical expression.</xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ct:PharmMLRootType">
                <xs:choice maxOccurs="1">
                    <xs:element ref="math:LogicBinop"/>
                    <xs:element ref="math:LogicUniop"/>
                    <xs:element ref="ct:Scalar"/>
                    <xs:element ref="math:Constant"/>
                    <xs:element ref="ct:SymbRef"/>
                    <xs:element ref="math:Binop"/>
                    <xs:element ref="math:Uniop"/>
                    <xs:element ref="math:FunctionCall"/>
                    <xs:element ref="math:Sum"/>
                    <xs:element ref="math:Product"/>
                    <xs:element ref="math:VectorSelector"/>
                    <xs:element ref="math:MatrixSelector"/>
                    <xs:element ref="mdef:Probability"/>
                </xs:choice>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="LogicUniOpType">
        <xs:complexContent>
            <xs:extension base="math:LogicExprType">
                <xs:attribute name="op" use="required">
                    <xs:annotation>
                        <xs:documentation>The unary operator type.</xs:documentation>
                    </xs:annotation>
                    <xs:simpleType>
                        <xs:restriction base="xs:Name">
                            <xs:enumeration value="isDefined"/>
                            <xs:enumeration value="not"/>
                        </xs:restriction>
                    </xs:simpleType>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="EquationType">
        <xs:annotation>
            <xs:documentation>Complex Type that defines a mathematical equation.</xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ct:PharmMLRootType">
                <xs:choice>
                    <xs:element ref="ct:Scalar"/>
                    <xs:element maxOccurs="1" minOccurs="1" ref="ct:SymbRef"/>
                    <xs:element ref="math:Binop"/>
                    <xs:element ref="math:Uniop"/>
                    <xs:element name="Piecewise" type="math:PiecewiseType">
                        <xs:annotation>
                            <xs:documentation>Defines a piecewise expression.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element ref="math:FunctionCall"/>
                    <xs:element ref="math:Sum"/>
                    <xs:element ref="math:Product"/>
                    <xs:element ref="ct:Delay"/>
                    <xs:element ref="math:VectorSelector"/>
                    <xs:element ref="math:MatrixSelector"/>
                    <xs:element ref="mdef:Probability"/>
                </xs:choice>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="FunctionCallType">
        <xs:annotation>
            <xs:documentation>A type defining a function call.</xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ct:PharmMLRootType">
                <xs:sequence>
                    <xs:element ref="ct:SymbRef"/>
                    <xs:element maxOccurs="unbounded" minOccurs="0" name="FunctionArgument">
                        <xs:annotation>
                            <xs:documentation>An argument of the function.</xs:documentation>
                        </xs:annotation>
                        <xs:complexType>
                            <xs:complexContent>
                                <xs:extension base="math:FunctionArgumentType"/>
                            </xs:complexContent>
                        </xs:complexType>
                    </xs:element>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="FunctionArgumentType">
        <xs:annotation>
            <xs:documentation>A type defining an argument of a function being called.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element minOccurs="0" ref="ct:Symbol"/>
            <xs:element minOccurs="0" ref="ct:Description"/>
            <xs:choice>
                <xs:element maxOccurs="1" ref="math:Equation"/>
                <xs:element ref="ct:Scalar"/>
                <xs:element ref="math:Constant"/>
                <xs:element ref="ct:SymbRef"/>
                <xs:element ref="math:Sum"/>
                <xs:element ref="math:Product"/>
                <xs:element ref="math:VectorSelector"/>
                <xs:element ref="math:MatrixSelector"/>
                <xs:element ref="mdef:Probability"/>
            </xs:choice>
        </xs:sequence>
        <xs:attribute name="symbId" type="ct:SymbolIdType" use="required">
            <xs:annotation>
                <xs:documentation>The symbold ID of the argument.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    
    
        <xs:complexType name="MatrixType">
        <xs:annotation>
            <xs:documentation>
                The type specifies the content of a matrix.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ct:PharmMLRootType">
                <xs:sequence>
                    <xs:element name="RowNames" minOccurs="0" type="math:MatrixColumnRowNames">
                        <xs:annotation>
                            <xs:documentation>Names of the matrix rows.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element name="ColumnNames" minOccurs="0" type="math:MatrixColumnRowNames">
                        <xs:annotation>
                            <xs:documentation>Names of the matrix columns.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:choice minOccurs="0" maxOccurs="unbounded">
                        <xs:element name="MatrixRow" type="math:MatrixRowType" maxOccurs="unbounded">
                            <xs:annotation>
                                <xs:documentation>A row in the matrix.</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                        <xs:element name="MatrixCell" type="math:MatrixCellType" maxOccurs="unbounded">
                            <xs:annotation>
                                <xs:documentation>Single matrix element with indexes.</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                        <xs:element name="MatrixBlock" type="math:MatrixBlockType" maxOccurs="unbounded">
                            <xs:annotation>
                                <xs:documentation>Matrix block (submatrix) with indexes.</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                    </xs:choice>
                </xs:sequence>
                <xs:attribute name="diagDefault" type="xs:double" default="0">
                    <xs:annotation>
                        <xs:documentation>The default diagonal value.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="offDiagDefault" type="xs:double" default="0">
                    <xs:annotation>
                        <xs:documentation>The default off-diagonal value.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="numbCols" type="xs:integer">
                    <xs:annotation>
                        <xs:documentation>The number of columns.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="numbRows" type="xs:integer">
                    <xs:annotation>
                        <xs:documentation>The number of rows.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="matrixType" use="required">
                    <xs:annotation>
                        <xs:documentation>Mathematical type of the matrix.</xs:documentation>
                    </xs:annotation>
                    <xs:simpleType>
                        <xs:restriction base="xs:Name">
                            <xs:enumeration value="Any"/>
                            <xs:enumeration value="Diagonal"/>
                            <xs:enumeration value="LowerTriangular"/>
                            <xs:enumeration value="UpperTriangular"/>
                            <xs:enumeration value="Symmetric"/>
                        </xs:restriction>
                    </xs:simpleType>
                </xs:attribute>
                <xs:attribute name="symbId" type="ct:SymbolIdType" use="optional"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    
    <xs:complexType name="MatrixColumnRowNames">
        <xs:annotation>
            <xs:documentation>
                Type specifying names of the row and columns.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ct:PharmMLRootType">
                <xs:choice maxOccurs="unbounded">
                    <xs:element ref="ct:String">
                        <xs:annotation>
                            <xs:documentation>A string.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element ref="ct:SymbRef">
                        <xs:annotation>
                            <xs:documentation>A variable reference.</xs:documentation>
                        </xs:annotation>
                    </xs:element>            
                </xs:choice>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    
    <xs:complexType name="MatrixCellType">
        <xs:annotation>
            <xs:documentation>
                This type specifies a matrix cell - with indexes.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ct:PharmMLRootType">
                <xs:sequence>
                    <xs:element name="CellRow" type="math:MatrixVectorIndexType"/>
                    <xs:element name="CellColumn" type="math:MatrixVectorIndexType"/>
                    <xs:choice maxOccurs="unbounded">
                        <xs:element ref="ct:Scalar">
                            <xs:annotation>
                                <xs:documentation>A scalar value to be inserted into the matrix cell.</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                        <xs:element ref="ct:SymbRef"/>
                    </xs:choice>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    
    <xs:complexType name="MatrixRowType">
        <xs:annotation>
            <xs:documentation>This type specifies a row of values in a matrix. The row can contain indexed cells or 
                scalars/symbols filling the whole row. Index of the matrix row is optoinal. If cells are defined inside rows, 
                the cells will be indexed relative to the row.</xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ct:PharmMLRootType">
                <xs:sequence>
                    <xs:element name="RowIndex" minOccurs="0" type="math:MatrixVectorIndexType"/>
                    <xs:choice minOccurs="0" maxOccurs="unbounded">
                        <xs:element ref="ct:Scalar">
                            <xs:annotation>
                                <xs:documentation>A scalar value to be inserted into the vector at this point.</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                        <xs:element ref="ct:Sequence">
                            <xs:annotation>
                                <xs:documentation>A sequence (or uniform series) of numbers to be inserted into the vector at this point.</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                        <xs:element ref="ct:SymbRef"/>
                    </xs:choice>
                </xs:sequence>
                <xs:attribute name="default" type="xs:double" default="0">
                    <xs:annotation>
                        <xs:documentation>The default row value - overwrites the matrix default.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    
    <xs:complexType name="MatrixBlockType">
        <xs:annotation>
            <xs:documentation>
                The type specifies the content of a block/submatrix of a matrix.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ct:PharmMLRootType">
                <xs:sequence>
                    <xs:element name="BlockStartRow" type="math:MatrixVectorIndexType">
                        <xs:annotation>
                            <xs:documentation>The row index.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element name="BlockStartColumn" type="math:MatrixVectorIndexType">
                        <xs:annotation>
                            <xs:documentation>The column index.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:choice>
                        <xs:element name="BlockRow" type="math:MatrixRowType" maxOccurs="unbounded">
                            <xs:annotation>
                                <xs:documentation>A row in the matrix.</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                        <xs:element name="BlockCell" type="math:MatrixCellType" maxOccurs="unbounded">
                            <xs:annotation>
                                <xs:documentation>Single matrix element with indexes relative to the block start coordinates.</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                    </xs:choice>
                </xs:sequence>
                <xs:attribute name="diagDefault" type="xs:double" default="0">
                    <xs:annotation>
                        <xs:documentation>The default diagonal value.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="offDiagDefault" type="xs:double" default="0">
                    <xs:annotation>
                        <xs:documentation>The default off-diagonal value.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="numbCols" type="xs:integer">
                    <xs:annotation>
                        <xs:documentation>The number of columns.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="numbRows" type="xs:integer">
                    <xs:annotation>
                        <xs:documentation>The number of rows.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="MatrixBlockSelectorType">
        <xs:annotation>
            <xs:documentation>
                This type specifies a block selector for a matrix.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ct:PharmMLRootType">
                <xs:sequence>
                    <xs:element name="BlockStartRow" type="math:MatrixVectorIndexType"/>
                    <xs:element name="BlockStartColumn" type="math:MatrixVectorIndexType"/>
                    <xs:element name="RowsNumber" type="math:MatrixVectorIndexType"/>
                    <xs:element name="ColumnsNumber" type="math:MatrixVectorIndexType"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    
    <xs:complexType name="MatrixCellSelectorType">
        <xs:annotation>
            <xs:documentation>
                This type specifies cell selector for a matrix.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ct:PharmMLRootType">
                <xs:sequence>
                    <xs:element name="RowIndex" type="math:MatrixVectorIndexType"/>
                    <xs:element name="ColumnIndex" type="math:MatrixVectorIndexType"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="MatrixSelectorType">
        <xs:annotation>
            <xs:documentation>
                Type for matrix selector.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ct:PharmMLRootType">
                <xs:sequence>
                    <xs:element ref="ct:SymbRef"/>
                    <xs:choice>
                        <xs:element name="Cell" type="math:MatrixCellSelectorType"/>
                        <xs:element name="Block" type="math:MatrixBlockSelectorType"/>                            
                        <xs:element name="Row" type="math:MatrixVectorIndexType"/>
                        <xs:element name="Column" type="math:MatrixVectorIndexType"/>
                    </xs:choice>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    
    <xs:element name="MatrixSelector" type="math:MatrixSelectorType">
        <xs:annotation>
            <xs:documentation>
                Allows to select a choosen matrix element/row/column/block.
            </xs:documentation>
        </xs:annotation>
    </xs:element>
    
    
    <xs:complexType name="MatrixVectorIndexType">
        <xs:complexContent>
            <xs:extension base="ct:PharmMLRootType">
                <xs:choice>
                    <xs:element ref="ct:Int">
                        <xs:annotation>
                            <xs:documentation>An integer value.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element ref="ct:SymbRef">
                        <xs:annotation>
                            <xs:documentation>A variable reference.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                </xs:choice>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    
    <xs:complexType name="SumProductIndexType">
        <xs:complexContent>
            <xs:extension base="ct:PharmMLRootType">
                <xs:choice>
                    <xs:element ref="ct:SymbRef">
                        <xs:annotation>
                            <xs:documentation>A variable reference.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                </xs:choice>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    
    <xs:complexType name="SumIndexSetType">
        <xs:annotation>
            <xs:documentation>Type for sum index set.</xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ct:PharmMLRootType">
                <xs:sequence>
                    <xs:element ref="math:Vector">
                        <xs:annotation>
                            <xs:documentation>Sum index is defined by a vector</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    
    <xs:complexType name="SumType">
        <xs:annotation>
            <xs:documentation>Type defining summation.</xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ct:PharmMLRootType">
                <xs:sequence>
                    <xs:choice>
                        <xs:element ref="ct:SymbRef">
                            <xs:annotation>
                                <xs:documentation>A variable reference.</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                        <!-- TEST -->
                        <xs:element ref="mdef:Probability"/>
                        <!-- /TEST -->
                    </xs:choice>
                    <xs:element name="SumIndex" type="math:SumProductIndexType"/>
                    <xs:choice>
                        <xs:sequence>
                            <xs:element name="LowLimit" type="math:LowUpLimitType">
                                <xs:annotation>
                                    <xs:documentation>Defining first index in the sum.</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                            <xs:element name="UpLimit" type="math:LowUpLimitType">
                                <xs:annotation>
                                    <xs:documentation>Defining last index in the sum.</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                        </xs:sequence>
                        <xs:element name="SumIndexSet" type="math:SumIndexSetType">
                            <xs:annotation>
                                <xs:documentation>Definig a set of indexes for summation, i.e. if non-consequtive
                                    element are to be considered.</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                    </xs:choice>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    
    <xs:complexType name="ProductType">
        <xs:annotation>
            <xs:documentation>Type defining product.</xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ct:PharmMLRootType">
                <xs:sequence>
                    <xs:element ref="ct:SymbRef">
                        <xs:annotation>
                            <xs:documentation>A variable reference.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element name="ProductIndex" type="math:SumProductIndexType"/>
                    <xs:element name="LowLimit" type="math:LowUpLimitType">
                        <xs:annotation>
                            <xs:documentation>Defining first index in the sum.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element name="UpLimit" type="math:LowUpLimitType">
                        <xs:annotation>
                            <xs:documentation>Defining last index in the sum.</xs:documentation>
                        </xs:annotation>
                    </xs:element>            
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    
    <!-- TEST -->
    <xs:complexType name="IntegralType">
        <xs:annotation>
            <xs:documentation>Type defining an integral.</xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ct:PharmMLRootType">
                <xs:sequence>
                    <!-- START IntegrationDomain -->
                    <xs:choice>
                        <xs:element ref="ct:SymbRef">
                            <xs:annotation>
                                <xs:documentation>A variable reference.</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                    </xs:choice>
                    <xs:element name="IntegrationVariableIndex" type="math:SumProductIndexType"/>
                    <xs:choice>
                        <xs:sequence>
                            <xs:element name="LowLimit" type="math:LowUpLimitType">
                                <xs:annotation>
                                    <xs:documentation>Defining first index in the sum.</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                            <xs:element name="UpLimit" type="math:LowUpLimitType">
                                <xs:annotation>
                                    <xs:documentation>Defining last index in the sum.</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                        </xs:sequence>
                        <xs:element name="SumIndexSet" type="math:SumIndexSetType">
                            <xs:annotation>
                                <xs:documentation>Definig a set of indexes for summation, i.e. if non-consequtive
                                    element are to be considered.</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                    </xs:choice>
                </xs:sequence>
                <!-- END IntegrationDomain -->
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    
    <!-- /TEST -->
    
    <xs:complexType name="LowUpLimitType">
        <xs:complexContent>
            <xs:extension base="ct:PharmMLRootType">
                <xs:choice>
                    <xs:element ref="ct:Int">
                        <xs:annotation>
                            <xs:documentation>An integer value.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element ref="ct:SymbRef">
                        <xs:annotation>
                            <xs:documentation>A variable reference.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                </xs:choice>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    
    
    <xs:complexType name="VectorType">
        <xs:annotation>
            <xs:documentation>
                Traditional vector, with numerical values only and facultative index.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ct:PharmMLRootType">
                <xs:choice>
                    <xs:element name="VectorElements" type="math:VectorElementsType">
                        <xs:annotation>
                            <xs:documentation>Basic vector element - numerical value or symbolRef.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:choice maxOccurs="unbounded">
                        <xs:element name="VectorCell" type="math:VectorCellType" maxOccurs="unbounded">
                            <xs:annotation>
                                <xs:documentation>Single vector element with index.</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                        <xs:element name="VectorSegment" type="math:VectorSegmentType" maxOccurs="unbounded">
                            <xs:annotation>
                                <xs:documentation>Consecutive vector elements with start index and segment length.</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                    </xs:choice>
                </xs:choice>
                <xs:attribute name="length" type="xs:integer">
                    <xs:annotation>
                        <xs:documentation>The length of the vector - optional.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="default" type="xs:double" default="0">
                    <xs:annotation>
                        <xs:documentation>Default value of vector - set to 0.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    
    <xs:complexType name="VectorElementsType">
        <xs:annotation>
            <xs:documentation>
                This type specifies a vector element - without indexes.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ct:PharmMLRootType">
                <xs:choice maxOccurs="unbounded">
                    <xs:element ref="ct:Scalar">
                        <xs:annotation>
                            <xs:documentation>A scalar value to be inserted into the vector at this point.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element ref="ct:Sequence">
                        <xs:annotation>
                            <xs:documentation>A sequence (or uniform series) of numbers to be inserted into the vector at this point.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element ref="ct:SymbRef"/>
                </xs:choice>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    
    <xs:complexType name="VectorCellType">
        <xs:annotation>
            <xs:documentation>
                This type specifies a vector cell - with index.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ct:PharmMLRootType">
                <xs:sequence>
                    <xs:element name="VectorIndex" type="math:MatrixVectorIndexType"/>
                    <xs:choice maxOccurs="unbounded">
                        <xs:element ref="ct:Scalar">
                            <xs:annotation>
                                <xs:documentation>A scalar value to be inserted into the vector at this point.</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                        <xs:element ref="ct:SymbRef"/>
                    </xs:choice>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    
    <xs:complexType name="VectorSegmentType">
        <xs:annotation>
            <xs:documentation>
                A segment of a vector with numerical values or variables and facultative index.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ct:PharmMLRootType">
                <xs:sequence>
                    <xs:element name="StartIndex" type="math:MatrixVectorIndexType"/>
                    <xs:element name="SegmentLength" type="math:MatrixVectorIndexType"/>                    
                    <xs:element name="VectorElements" minOccurs="0" type="math:VectorElementsType">
                        <xs:annotation>
                            <xs:documentation>Basic vector element - numerical value or symbolRef.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                </xs:sequence>
                <xs:attribute name="default" type="xs:double" default="0">
                    <xs:annotation>
                        <xs:documentation>Default value of vector set to 0.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    
    <xs:complexType name="VectorSegmentSelectorType">
        <xs:annotation>
            <xs:documentation>
                This type specifies a vector segment.
            </xs:documentation>            
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ct:PharmMLRootType">
                <xs:sequence maxOccurs="unbounded">
                    <xs:element name="StartIndex" type="math:MatrixVectorIndexType"/>
                    <xs:element name="SegmentLength" type="math:MatrixVectorIndexType"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    
    <xs:complexType name="VectorSelectorType">
        <xs:annotation>
            <xs:documentation>
                Type for vector selector.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="ct:PharmMLRootType">
                <xs:sequence>
                    <xs:element ref="ct:SymbRef"/>
                    <xs:element name="Head" minOccurs="0" type="math:MatrixVectorIndexType"/>
                    <xs:choice maxOccurs="unbounded">
                        <xs:element name="Cell" minOccurs="0" maxOccurs="unbounded" type="math:MatrixVectorIndexType"/>
                        <xs:element name="Segment" minOccurs="0" maxOccurs="unbounded" type="math:VectorSegmentSelectorType"/>                            
                    </xs:choice>
                    <xs:element name="Tail" minOccurs="0" type="math:MatrixVectorIndexType"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    
    <xs:element name="VectorSelector" type="math:VectorSelectorType">
        <xs:annotation>
            <xs:documentation>
                Allows to select a choosen vector element.
            </xs:documentation>
        </xs:annotation>
    </xs:element>
    
    <!-- elements -->
    <xs:element name="Sum" type="math:SumType">
        <xs:annotation>
            <xs:documentation>Sigma sum element.</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="Product" type="math:ProductType">
        <xs:annotation>
            <xs:documentation>Product element.</xs:documentation>
        </xs:annotation>
    </xs:element>    
    <xs:element name="Matrix" type="math:MatrixType">
        <xs:annotation>
            <xs:documentation>Element defines a matrix</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="Vector" type="math:VectorType" substitutionGroup="ct:Arrays">
        <xs:annotation>
            <xs:documentation>Element defines a vector type, scalars and sequences</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="Otherwise">
        <xs:annotation>
            <xs:documentation>The otherwise case in a piecewise function.</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="Constant" type="math:ConstantType">
        <xs:annotation>
            <xs:documentation>A constant symbol.</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="FunctionCall" type="math:FunctionCallType">
        <xs:annotation>
            <xs:documentation>A function call.</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="Binop" type="math:BinopType">
        <xs:annotation>
            <xs:documentation>A binary operator.</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="Uniop" type="math:UniopType">
        <xs:annotation>
            <xs:documentation>A unary operator.</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="LogicBinop" type="math:LogicBinOpType">
        <xs:annotation>
            <xs:documentation>A logical binary operator used in logical expressions.</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="LogicUniop" type="math:LogicUniOpType">
        <xs:annotation>
            <xs:documentation>A logical unary operator used in logical expressions.</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="Condition">
        <xs:annotation>
            <xs:documentation>A condition defined by a logical expression. Can be evaluated to True or False.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="math:LogicConditionType"> </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="Equation">
        <xs:annotation>
            <xs:documentation>A mathematical expression that is evaluated to a scalar type.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="math:EquationType"> </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
</xs:schema>
